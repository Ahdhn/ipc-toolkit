
.. _program_listing_file_src_distance_point_line.hpp:

Program Listing for File point_line.hpp
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_distance_point_line.hpp>` (``src/distance/point_line.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <Eigen/Core>
   
   #include <ipc/distance/point_point.hpp>
   
   namespace ipc {
   
   template <typename DerivedP, typename DerivedE0, typename DerivedE1>
   auto point_line_distance(
       const Eigen::MatrixBase<DerivedP>& p,
       const Eigen::MatrixBase<DerivedE0>& e0,
       const Eigen::MatrixBase<DerivedE1>& e1)
   {
       assert(p.size() == 2 || p.size() == 3);
       assert(e0.size() == 2 || e0.size() == 3);
       assert(e1.size() == 2 || e1.size() == 3);
   
       if (p.size() == 2) {
           auto e = e1 - e0;
           auto numerator =
               (e[1] * p[0] - e[0] * p[1] + e1[0] * e0[1] - e1[1] * e0[0]);
           return numerator * numerator / e.squaredNorm();
       } else {
           return cross(e0 - p, e1 - p).squaredNorm() / (e1 - e0).squaredNorm();
       }
   }
   
   // Symbolically generated derivatives;
   namespace autogen {
       void point_line_distance_gradient_2D(
           double v01,
           double v02,
           double v11,
           double v12,
           double v21,
           double v22,
           double g[6]);
   
       void point_line_distance_gradient_3D(
           double v01,
           double v02,
           double v03,
           double v11,
           double v12,
           double v13,
           double v21,
           double v22,
           double v23,
           double g[9]);
   
       void point_line_distance_hessian_2D(
           double v01,
           double v02,
           double v11,
           double v12,
           double v21,
           double v22,
           double H[36]);
   
       void point_line_distance_hessian_3D(
           double v01,
           double v02,
           double v03,
           double v11,
           double v12,
           double v13,
           double v21,
           double v22,
           double v23,
           double H[81]);
   } // namespace autogen
   
   template <
       typename DerivedP,
       typename DerivedE0,
       typename DerivedE1,
       typename DerivedGrad>
   void point_line_distance_gradient(
       const Eigen::MatrixBase<DerivedP>& p,
       const Eigen::MatrixBase<DerivedE0>& e0,
       const Eigen::MatrixBase<DerivedE1>& e1,
       Eigen::PlainObjectBase<DerivedGrad>& grad)
   {
       assert(p.size() == 2 || p.size() == 3);
       assert(e0.size() == 2 || e0.size() == 3);
       assert(e1.size() == 2 || e1.size() == 3);
   
       grad.resize(p.size() + e0.size() + e1.size());
       if (p.size() == 2) {
           autogen::point_line_distance_gradient_2D(
               p[0], p[1], e0[0], e0[1], e1[0], e1[1], grad.data());
       } else {
           autogen::point_line_distance_gradient_3D(
               p[0], p[1], p[2], e0[0], e0[1], e0[2], e1[0], e1[1], e1[2],
               grad.data());
       }
   }
   
   template <
       typename DerivedP,
       typename DerivedE0,
       typename DerivedE1,
       typename DerivedHess>
   void point_line_distance_hessian(
       const Eigen::MatrixBase<DerivedP>& p,
       const Eigen::MatrixBase<DerivedE0>& e0,
       const Eigen::MatrixBase<DerivedE1>& e1,
       Eigen::PlainObjectBase<DerivedHess>& hess)
   {
       assert(p.size() == 2 || p.size() == 3);
       assert(e0.size() == 2 || e0.size() == 3);
       assert(e1.size() == 2 || e1.size() == 3);
   
       hess.resize(
           p.size() + e0.size() + e1.size(), p.size() + e0.size() + e1.size());
       if (p.size() == 2) {
           autogen::point_line_distance_hessian_2D(
               p[0], p[1], e0[0], e0[1], e1[0], e1[1], hess.data());
       } else {
           autogen::point_line_distance_hessian_3D(
               p[0], p[1], p[2], e0[0], e0[1], e0[2], e1[0], e1[1], e1[2],
               hess.data());
       }
   }
   
   } // namespace ipc
